using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Text;
using System.IO;
using System.Security;
using Flame.Compiler;
using Pixie;

namespace CompareTest
{
    /// <summary>
    /// A mutable state structure that can be used by statements to start
    /// processes and check for errors.
    /// </summary>
    public class ExecutionState
    {
        public const this(
            set string WorkingDirectory, set ICompilerLog Log,
            set int ExitCode);

        public const this(set string WorkingDirectory, set ICompilerLog Log)
        {
            this.ExitCode = 0;
        }

        /// <summary>
        /// Gets this state object's working directory.
        /// </summary>
        public string WorkingDirectory { get; private set; }

        /// <summary>
        /// Gets or sets the last exit code. Any nonzero exit code
        /// points to an error.
        /// </summary>
        public int ExitCode { get; set; }

        /// <summary>
        /// Gets the log that has been associated with this execution state.
        /// </summary>
        public ICompilerLog Log { get; private set; }

        /// <summary>
        /// Gets a boolean value that tells whether this state is in an
        /// error state. This is dependent on the last exit code.
        /// A state that is in error cannot be instructed to
        /// execute further processes.
        /// </summary>
        public bool HasErrored { get { return ExitCode != 0; } }

        /// <summary>
        /// Creates a new execution state from this execution state.
        /// </summary>
        public ExecutionState Fork()
        {
            return Fork(WorkingDirectory);
        }

        /// <summary>
        /// Creates a new execution state from this execution state, with
        /// the given working directory.
        /// </summary>
        public ExecutionState Fork(string NewWorkingDirectory)
        {
            return new ExecutionState(NewWorkingDirectory, Log, ExitCode);
        }

        /// <summary>
        /// Creates a path from the given string that is local to this
        /// execution state's working directory.
        /// </summary>
        public string GetLocalPath(string RelativePath)
        {
            return Path.Combine(WorkingDirectory, RelativePath);
        }

        /// <summary>
        /// Runs a process with the given name and arguments, waits for
        /// completion, and then returns its output.
        /// </summary>
        public string RunProcess(string Name, string Arguments, string Input)
        {
            if (HasErrored)
                throw new InvalidOperationException(
                    "Cannot start a process if a previously executed " +
                    "process did not terminate successfully.");

            string fixedName;
            if (Name.IndexOf(Path.DirectorySeparatorChar) >= 0 ||
                Name.IndexOf(Path.AltDirectorySeparatorChar) >= 0)
            {
                fixedName = GetLocalPath(Name);
            }
            else
            {
                fixedName = Name;
            }

            Log.LogEvent(new LogEntry(
                "Status",
                "starting process '" + fixedName + " " + Arguments + "'."));

            var process = new Process();
            process.StartInfo.WorkingDirectory = WorkingDirectory;
            process.StartInfo.FileName = fixedName;
            process.StartInfo.Arguments = Arguments;
            process.StartInfo.UseShellExecute = false;
            process.StartInfo.RedirectStandardInput = true;
            process.StartInfo.RedirectStandardOutput = true;
            process.StartInfo.RedirectStandardError = true;

            string output;
            try
            {
                process.Start();

                // Write to the process' standard input.
                process.StandardInput.Write(Input);
                process.StandardInput.Close();

                output = process.StandardOutput.ReadToEnd();

                process.WaitForExit();
                this.ExitCode = process.ExitCode;

                if (HasErrored)
                {
                    // Write output to log for debugging purposes.
                    string err = process.StandardError.ReadToEnd();
                    if (!string.IsNullOrWhiteSpace(err))
                    {
                        Write(err);
                    }
                }
            }
            catch (Win32Exception ex)
            {
                this.ExitCode = 1;
                output = ex.Message;
            }

            return output;
        }

        /// <summary>
        /// Runs a process from the given command, waits for
        /// completion, and then returns its output.
        /// </summary>
        public string RunProcess(string Command, string Input)
        {
            string trimmedCommand = Command.Trim(null);
            int firstSpace = trimmedCommand.IndexOf(' ');
            if (firstSpace < 0)
                return RunProcess(trimmedCommand, "", Input);
            else
                return RunProcess(
                    trimmedCommand.Substring(0, firstSpace),
                    trimmedCommand.Substring(firstSpace + 1),
                    Input);
        }

        /// <summary>
        /// Runs a process from the given command, waits for
        /// completion, and then returns its output.
        /// </summary>
        public string RunProcess(string Command)
        {
            return RunProcess(Command, "");
        }

        /// <summary>
        /// Writes a message to the console.
        /// </summary>
        public void Write(string Message)
        {
            Console.Write(Message);
        }

        /// <summary>
        /// Creates a file at the given path with the given contents.
        /// A source location specifies the responsible code fragment if
        /// anything goes wrong.
        /// </summary>
        public void CreateFile(string Path, string Contents, SourceLocation Location)
        {
            string locPath = GetLocalPath(Path);

            try
            {
                var fs = new FileStream(Path, FileMode.Create, FileAccess.Write);
                var reader = new StreamWriter(fs);
                reader.Write(Contents);
                reader.Dispose();
                fs.Dispose();
            }
            catch (DirectoryNotFoundException ex)
            {
                Log.LogError(new LogEntry(
                    "missing directory",
                    "'" + locPath + "' cannot not be created, because its parent " +
                    "directory does not exist.",
                    Location));
                ExitCode = 1;
            }
            catch (SecurityException ex)
            {
                Log.LogError(new LogEntry(
                    "unathorized access",
                    "did not have permission to access '" + locPath + "'.",
                    Location));
                ExitCode = 1;
            }
            catch (UnauthorizedAccessException ex)
            {
                Log.LogError(new LogEntry(
                    "unathorized access",
                    "did not have write-access to '" + locPath + "'.",
                    Location));
                ExitCode = 1;
            }
            catch (PathTooLongException ex)
            {
                Log.LogError(new LogEntry(
                    "path too long",
                    "path '" + locPath + "' is too long for the OS to handle.",
                    Location));
                ExitCode = 1;
            }
        }
    }
}
