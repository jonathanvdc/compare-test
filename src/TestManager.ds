using System;
using System.Collections.Generic;
using Flame.Compiler;
using Flame.Front;
using Flame.Front.Cli;
using Flame.Front.Options;
using Pixie;

namespace CompareTest
{
    /// <summary>
    /// A data structure that describes the outcome of a test.
    /// </summary>
    public class TestOutcome
    {
        public const this(
            set PathIdentifier Path, set Configuration Config,
            set int Index, set bool HasFailed);

        /// <summary>
        /// Gets the test's path.
        /// </summary>
        public PathIdentifier Path { get; private set; }

        /// <summary>
        /// Gets the test's configuration.
        /// </summary>
        public Configuration Config { get; private set; }

        /// <summary>
        /// Gets the test/configuration pair's index.
        /// </summary>
        public int Index { get; private set; }

        /// <summary>
        /// Gets a boolean that tells if this test was a failure.
        /// </summary>
        public bool HasFailed { get; private set; }
    }

    /// <summary>
    /// A test case that has been primed for execution.
    /// </summary>
    public class TestExecution
    {
        public this(
            set TestCase Test, set void(TestOutcome, int) LogCompleted,
            set int TotalConfigurationIndex, set int TotalConfigurationCount)
        { }

        /// <summary>
        /// Gets the test case to run.
        /// </summary>
        public TestCase Test { get; private set; }

        /// <summary>
        /// A delegate that logs a message that notifies the user of the outcome
        /// of the given test. The total number of tests/configuration pairs
        /// is also given.
        /// </summary>
        public void(TestOutcome, int) LogCompleted { get; private set; }

        /// <summary>
        /// Gets the index of the test case's first configuration.
        /// </summary>
        public int TotalConfigurationIndex { get; private set; }

        /// <summary>
        /// Gets the total number of configurations.
        /// </summary>
        public int TotalConfigurationCount { get; private set; }

        /// <summary>
        /// Runs this configuration.
        /// </summary>
        public IReadOnlyList<TestOutcome> Run()
        {
            return Test.Run(LogCompleted, TotalConfigurationIndex, TotalConfigurationCount);
        }
    }

    /// <summary>
    /// A class of objects that take care of running tests.
    /// </summary>
    public class TestManager
    {
        alias ConfigDict = Dictionary<string, IStatement>;

        public const this(
            set IReadOnlyList<TestCase> Tests,
            set void(TestOutcome, int) LogCompleted);

        /// <summary>
        /// Gets a dictionary of all tests to run.
        /// </summary>
        public IReadOnlyList<TestCase> Tests { get; private set; }

        /// <summary>
        /// A delegate that logs a message that notifies the user of the outcome
        /// of the given test. The total number of tests/configuration pairs
        /// is also given.
        /// </summary>
        public void(TestOutcome, int) LogCompleted { get; private set; }

        /// <summary>
        /// Runs all tests stored in this test manager. All test outcomes are
        /// stored in a list, which is returned.
        /// </summary>
        public IReadOnlyList<TestOutcome> RunTests()
        {
            // Compute the total number of configurations.
            int totalConfigCount = 0;
            foreach (var testCase in Tests)
            {
                totalConfigCount += testCase.Configurations.Count;
            }

            var allOutcomes = new List<TestOutcome>();

            // Finally, run all tests.
            foreach (var testCase in Tests)
            {
                var exec = new TestExecution(
                    testCase, LogCompleted, allOutcomes.Count, totalConfigCount);
                allOutcomes.AddRange(exec.Run());
            }

            return allOutcomes;
        }
    }
}
