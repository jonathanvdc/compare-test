using System;
using System.Collections.Generic;
using Flame.Compiler;
using Flame.Front;
using Flame.Front.Cli;
using Flame.Front.Options;

namespace CompareTest
{
    /// <summary>
    /// A data structure that describes the outcome of a test.
    /// </summary>
    public class TestOutcome
    {
        public const this(
            set PathIdentifier Path, set Configuration Config,
            set int Index, set bool HasFailed);

        /// <summary>
        /// Gets the test's path.
        /// </summary>
        public PathIdentifier Path { get; private set; }

        /// <summary>
        /// Gets the test's configuration.
        /// </summary>
        public Configuration Config { get; private set; }

        /// <summary>
        /// Gets the test/configuration pair's index.
        /// </summary>
        public int Index { get; private set; }

        /// <summary>
        /// Gets a boolean that tells if this test was a failure.
        /// </summary>
        public bool HasFailed { get; private set; }
    }

    /// <summary>
    /// A class of objects that take care of running tests.
    /// </summary>
    public class TestManager
    {
        alias SectionTuple = Tuple<Section, Configuration, ExecutionState>;
        alias ConfigDict = Dictionary<string, IStatement>;

        public const string BuildSectionName = "build";
        public const string RunSectionName = "run";
        public const string ConfigurationsSectionName = "configs";
        public const string InitializationSectionName = "init";
        public const string TestsSectionName = "tests";
        public const string WorkingDirectoryKey = "working-directory";

        public const this(
            set IReadOnlyDictionary<PathIdentifier, SectionTuple> Tests,
            set void(TestOutcome, int) LogCompleted);

        /// <summary>
        /// Gets a dictionary of all tests to run.
        /// </summary>
        public IReadOnlyDictionary<PathIdentifier, SectionTuple> Tests { get; private set; }

        /// <summary>
        /// A delegate that logs a message that notifies the user of the outcome
        /// of the given test. The total number of tests/configuration pairs
        /// is also given.
        /// </summary>
        public void(TestOutcome, int) LogCompleted { get; private set; }

        /// <summary>
        /// Extracts all configuration statements from the given root section.
        /// </summary>
        private ConfigDict GetConfigurations(Section Root)
        {
            var results = new Dictionary<string, IStatement>();
            if (Root.Sections.TryGetValue(ConfigurationsSectionName, &Section configSec))
            {
                foreach (var sec in configSec.Sections)
                {
                    results[sec.Key] = sec.Value.AsStatement();
                }
            }
            else
            {
                results["default"] = EmptyStatement;
            }
            return results;
        }

        /// <summary>
        /// Creates a dictionary that maps all sections to their
        /// configurations.
        /// </summary>
        private Dictionary<Section, ConfigDict> GetAllConfigurations()
        {
            var results = new Dictionary<Section, ConfigDict>();
            foreach (var item in Tests.Values)
            {
                var sec = item.Item1;
                results[sec] = GetConfigurations(sec);
            }
            return results;
        }

        /// <summary>
        /// Runs a single test. The new total configuration index is returned.
        /// </summary>
        private int RunTest(
            Section Root, Configuration Config,
            ExecutionState State, PathIdentifier Path,
            ConfigDict AllConfigs, int ConfigurationIndex)
        {
            // The 'init' section already ran by this time.
            var rootStmt = Root.GetOptionalStatementSection(RunSectionName);
            var buildStmt = Root.GetOptionalStatementSection(BuildSectionName);

            int i = 0;
            foreach (var configPair in AllConfigs)
            {
                var configState = State.Fork();

                // Create a subconfiguration...
                var config = Config.CreateSubconfiguration(configPair.Key);
                // ...configure...
                config = configPair.Value.Execute(config, configState);
                // ...build...
                config = buildStmt.Execute(config, configState);
                // ...and run!
                rootStmt.Execute(config, configState);

                LogCompleted(new TestOutcome(
                    Path, config, ConfigurationIndex + i, configState.HasErrored),
                    Tests.Count);
                i++;
            }
            return ConfigurationIndex + AllConfigs.Count;
        }

        /// <summary>
        /// Runs all tests stored in this test manager.
        /// </summary>
        public void RunTests()
        {
            // First, get all configurations.
            var allConfigs = GetAllConfigurations();

            // Next, compute their count.
            int totalConfigCount = 0;
            foreach (var configPair in allConfigs)
            {
                totalConfigCount += configPair.Value.Count;
            }

            int i = 0;
            // Finally, run all tests.
            foreach (var testPair in Tests)
            {
                var testTuple = testPair.Value;
                i = RunTest(
                    testTuple.Item1, testTuple.Item2, testTuple.Item3,
                    testPair.Key, allConfigs[testTuple.Item1], i);
            }
        }
    }
}
