using System;
using System.Collections.Generic;
using Flame.Compiler;
using Flame.Front;
using Flame.Front.Cli;
using Flame.Front.Options;
using Pixie;

namespace CompareTest
{
    /// <summary>
    /// A data structure that describes the outcome of a test.
    /// </summary>
    public class TestOutcome
    {
        public const this(
            set PathIdentifier Path, set Configuration Config,
            set int Index, set bool HasFailed);

        /// <summary>
        /// Gets the test's path.
        /// </summary>
        public PathIdentifier Path { get; private set; }

        /// <summary>
        /// Gets the test's configuration.
        /// </summary>
        public Configuration Config { get; private set; }

        /// <summary>
        /// Gets the test/configuration pair's index.
        /// </summary>
        public int Index { get; private set; }

        /// <summary>
        /// Gets a boolean that tells if this test was a failure.
        /// </summary>
        public bool HasFailed { get; private set; }
    }

    /// <summary>
    /// A class of objects that take care of running tests.
    /// </summary>
    public class TestManager
    {
        alias ConfigDict = Dictionary<string, IStatement>;

        public const this(
            set IReadOnlyList<TestCase> Tests,
            set void(TestOutcome, int) LogCompleted);

        /// <summary>
        /// Gets a dictionary of all tests to run.
        /// </summary>
        public IReadOnlyList<TestCase> Tests { get; private set; }

        /// <summary>
        /// A delegate that logs a message that notifies the user of the outcome
        /// of the given test. The total number of tests/configuration pairs
        /// is also given.
        /// </summary>
        public void(TestOutcome, int) LogCompleted { get; private set; }

        /// <summary>
        /// Runs all tests stored in this test manager. All test outcomes are
        /// stored in a list, which is returned.
        /// </summary>
        public IReadOnlyList<TestOutcome> RunTests()
        {
            // Compute the total number of configurations.
            int totalConfigCount = 0;
            foreach (var testCase in Tests)
            {
                totalConfigCount += testCase.Configurations.Count;
            }

            var allOutcomes = new List<TestOutcome>();

            int i = 0;
            // Finally, run all tests.
            foreach (var testCase in Tests)
            {
                allOutcomes.AddRange(testCase.RunTest(LogCompleted, i, totalConfigCount));
                i += testCase.Configurations.Count;
            }

            return allOutcomes;
        }
    }
}
