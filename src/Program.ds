using System;
using System.Collections.Generic;
using System.IO;
using Flame.Compiler;
using Flame.Front;
using Flame.Front.Cli;
using Flame.Front.Options;

namespace CompareTest
{
    public static class Program
    {
        alias SectionTuple = Tuple<Section, Configuration, ExecutionState>;

        public const string UnixPlatformName = "unix";
        public const string MacOSXPlatformName = "osx";
        public const string WindowsPlatformName = "windows";
        public const string PlatformKey = "platform";
        public const string NetRuntimeKey = "net-runtime";

        private string GetPlatformName()
        {
            var platform = Environment.OSVersion.Platform;
            if (platform == PlatformID.Unix)
                return UnixPlatformName;
            else if (platform == PlatformID.MacOSX)
                return MacOSXPlatformName;
            else
                return WindowsPlatformName;
        }

        private Configuration GetDefaultConfiguration()
        {
            var configOptions = new Dictionary<string, string>();
            string platform = GetPlatformName();
            configOptions[PlatformKey] = platform;
            if (platform == WindowsPlatformName)
                // No need to explicitly name the runtime on Windows.
                configOptions[NetRuntimeKey] = "";
            else
                // Explicitly use 'mono' on other platforms.
                configOptions[NetRuntimeKey] = "mono";
            configOptions[TestManager.WorkingDirectoryKey] = Environment.CurrentDirectory;
            return new Configuration("default", configOptions);
        }

        public void Main(string[] Args)
        {
            // Parse build arguments, create a log
            var optParser = StringOptionParser.CreateDefault();
            var options = BuildArguments.Parse(optParser, Args);
            var log = new ConsoleLog(ConsoleEnvironment.AcquireConsole(options), options);
            var filtLog = new FilteredLog(options.GetLogFilter(), log);

            var config = GetDefaultConfiguration();

            var allTests = ReadAllTests(options.SourcePaths, filtLog, config);
            var manager = new TestManager(allTests, CreatePercentageLogger(log));
            var outcomes = manager.RunTests();
            var failures = FilterFailures(outcomes);
            log.Console.Write("Ran ");
            log.Console.Write(ToCountString(outcomes.Count, "test configuration"), log.ContrastForegroundColor);

            int exitCode = 0;
            if (failures.Count == 0)
            {
                log.Console.Write(", all of which were ");
                log.Console.Write("successful", log.MessageStyle);
                log.Console.Write(".");
                log.Console.WriteLine();
                if (filtLog.ErrorCount > 0)
                {
                    log.Console.Write("Encountered some ");
                    log.Console.Write("internal errors", log.ErrorStyle);
                    log.Console.Write(" on the way, though.");
                    log.Console.WriteLine();
                    exitCode = 1;
                }
            }
            else
            {
                log.Console.Write(". Found ");
                log.Console.Write(ToCountString(failures.Count, "failure"), log.ErrorStyle)
                log.Console.Write(".");
                log.Console.WriteLine();
                exitCode = 1;
            }

            Environment.Exit(exitCode);
        }

        private string ToCountString(int Count, string Type)
        {
            string prefix = Count + " " + Type;
            if (Count == 1)
                return prefix;
            else
                return prefix + "s";
        }

        private IReadOnlyList<TestOutcome> FilterFailures(IReadOnlyList<TestOutcome> Outcomes)
        {
            var results = new List<TestOutcome>();
            foreach (var item in Outcomes)
            {
                if (item.HasFailed)
                    results.Add(item);
            }
            return results;
        }

        private void(TestOutcome, int) CreatePercentageLogger(ConsoleLog Log)
        {
            return void(TestOutcome outcome, int n) =>
            {
                double percentage = 100.0 * (double)(outcome.Index + 1) / (double)n;
                string percentageStr = (string)(int)percentage;
                while (percentageStr.Length < 3)
                    percentageStr = " " + percentageStr;
                if (outcome.HasFailed)
                    Log.Console.Write("[" + percentageStr + "%]", Log.ErrorStyle);
                else
                    Log.Console.Write("[" + percentageStr + "%]", Log.MessageStyle);
                Log.Console.Write(" ");
                Log.Console.Write(outcome.Path.Path, Log.ContrastForegroundColor);
                Log.Console.Write(" - ");
                Log.Console.Write(outcome.Config.Name);
                Log.Console.WriteLine();
                return;
            };
        }

        /// <summary>
        /// Reads a single test file description, specified by the given path.
        /// </summary>
        public Section ReadTestDescription(PathIdentifier Path, ICompilerLog Log)
        {
            Section result = null;
            FileStream fs = null;
            try
            {
                fs = new FileStream(Path.Path, FileMode.Open, FileAccess.Read);
                var reader = new StreamReader(fs);
                try
                {
                    var text = reader.ReadToEnd();
                    var srcDoc = new SourceDocument(text, Path.Path);
                    var tokBuf = new TokenBuffer(new Lexer(srcDoc));
                    var parser = new Parser(Log);
                    result = parser.ParseRootSection(tokBuf);
                }
                finally
                {
                    reader.Dispose();
                }
            }
            catch (FileNotFoundException ex)
            {
                Log.LogError(new LogEntry("file not found", "the file at '" + Path + "' could not be found."));
            }
            finally
            {
                if (fs != null)
                    fs.Dispose();
            }
            return result;
        }

        /// <summary>
        /// Reads a single subtest, as specified by the given command.
        /// </summary>
        private void ReadSubtest(
            IStatement Command, ICompilerLog Log,
            Configuration Config, ExecutionState State,
            PathIdentifier BasePath,
            Dictionary<PathIdentifier, SectionTuple> Results,
            HashSet<string> ParsedPaths)
        {
            if (!(Command is CommandStatement))
            {
                Log.LogError(new LogEntry(
                    "invalid subtest",
                    "'" + Command + "' is not a valid subtest specification: " +
                    "subtests should be encoded as a sequence of semicolon-delimited " +
                    "paths.",
                    Command.Location));
                return;
            }

            var cmdStmt = (CommandStatement)Command;
            var pathStr = cmdStmt.Command.Evaluate(Config, State).Trim(null);
            ReadTestsRecursive(
                new PathIdentifier(BasePath.Parent, pathStr),
                Log, Config, State, Results, ParsedPaths);
        }

        /// <summary>
        /// Reads the test description specified by the given path,
        /// as well as all of its children.
        /// </summary>
        private void ReadTestsRecursive(
            PathIdentifier Path, ICompilerLog Log,
            Configuration Config, ExecutionState State,
            Dictionary<PathIdentifier, SectionTuple> Results,
            HashSet<string> ParsedPaths)
        {
            string absPath = Path.AbsolutePath.Path;
            if (!ParsedPaths.Add(absPath))
                // Looks like we have already parsed this file. Skip it.
                return;

            var sec = ReadTestDescription(Path, Log);
            if (sec == null)
                // Couldn't (properly) parse the test description.
                // No shame in that.
                return;

            // Fork the parent execution state.
            var secState = State.Fork(Path.Parent.Path);
            // Run the 'init' section first.
            var secInitStmt = sec.GetOptionalStatementSection(TestManager.InitializationSectionName);
            // Execute that statement to obtain a configuration object for
            // this section.
            var secConfig = secInitStmt.Execute(Config, secState);

            // Create a section tuple for this section, and add it to the
            // results dictionary.
            Results[Path] = new SectionTuple(sec, secConfig, secState);

            // Then try to find subtests in the 'tests' section.
            if (sec.Sections.TryGetValue(TestManager.TestsSectionName, &Section subtests))
            {
                foreach (var item in subtests.Statements)
                {
                    // Parse all subtest "command statements"
                    ReadSubtest(
                        item, Log, secConfig, secState,
                        Path, Results, ParsedPaths);
                }
            }
        }

        /// <summary>
        /// Reads all tests, as specified by the given sequence of paths.
        /// These tests are returned as a dictionary that maps path identifiers
        /// to tuples, which consist of a section,
        /// said section's configuration and its execution state.
        /// </summary>
        public IReadOnlyDictionary<PathIdentifier, SectionTuple> ReadAllTests(
            [PathIdentifier] Paths, ICompilerLog Log,
            Configuration Config)
        {
            var results = new Dictionary<PathIdentifier, SectionTuple>();
            var visitedPaths = new HashSet<string>();
            var state = new ExecutionState(
                Config.Variables[TestManager.WorkingDirectoryKey], Log);
            foreach (var item in Paths)
            {
                ReadTestsRecursive(item, Log, Config, state, results, visitedPaths);
            }
            return results;
        }
    }
}
