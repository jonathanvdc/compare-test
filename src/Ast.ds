using System;
using System.Collections.Generic;
using System.Text;
using Flame.Compiler;
// alias SourceLocation = Flame.Compiler.SourceLocation;
// alias CompilerLogExtensions = Flame.Compiler.CompilerLogExtensions;

namespace CompareTest
{
    /// <summary>
    /// A test "expression," which can be evaluated for a given configuration.
    /// </summary>
    public interface IExpression
    {
        /// <summary>
        /// Gets this test expression's source location.
        /// </summary>
        SourceLocation Location { get; }

        /// <summary>
        /// Evaluates this test expression for the given configuration.
        /// </summary>
        string Evaluate(Configuration Config, ExecutionState State);
    }

    /// <summary>
    /// A test "statement," which can change the configuration, or execute
    /// arbitrary programs.
    /// </summary>
    public interface IStatement
    {
        /// <summary>
        /// Gets this test expression's source location.
        /// </summary>
        SourceLocation Location { get; }

        /// <summary>
        /// Executes this statement. A new configuration is returned, which
        /// may or may not be the old configuration.
        /// </summary>
        Configuration Execute(Configuration Config, ExecutionState State);
    }

    /// <summary>
    /// An expression that consists of a single token.
    /// </summary>
    public class TokenExpression : IExpression
    {
        public const this(set Token Contents);

        /// <summary>
        /// Gets this token-expression's single token.
        /// </summary>
        public Token Contents { get; private set; }

        /// <summary>
        /// Gets this test expression's source location.
        /// </summary>
        public SourceLocation Location
        {
            get
            {
                if (TokenHelpers.IsTrivia(Contents.Type))
                    // Don't include leading and trailing trivia in diagnostics.
                    return null;
                else
                    return Contents.Location;
            }
        }

        /// <summary>
        /// Evaluates this test expression for the given configuration.
        /// </summary>
        public string Evaluate(Configuration Config, ExecutionState State)
        {
            return Contents.Contents;
        }

        public override string ToString()
        {
            return Contents.Contents;
        }
    }

    /// <summary>
    /// An expression that identifies a variable.
    /// </summary>
    public class VariableExpression : IExpression
    {
        public const this(set Token Identifier);

        /// <summary>
        /// Gets this replacement-expression's key token.
        /// </summary>
        public Token Identifier { get; private set; }

        /// <summary>
        /// Gets this test expression's source location.
        /// </summary>
        public SourceLocation Location { get { return Identifier.Location; } }

        /// <summary>
        /// Evaluates this test expression for the given configuration.
        /// </summary>
        public string Evaluate(Configuration Config, ExecutionState State)
        {
            return Config.Variables[Identifier.Contents];
        }

        public override string ToString()
        {
            return "$(" + Identifier.Contents + ")";
        }
    }

    /// <summary>
    /// An expression that evaluates an expression, and executes the result
    /// as a command.
    /// </summary>
    public class CommandExpression : IExpression
    {
        public const this(set IExpression Command);

        /// <summary>
        /// Gets the expression that describes the command this
        /// statement should execute.
        /// </summary>
        public IExpression Command { get; private set; }

        /// <summary>
        /// Gets this test expression's source location.
        /// </summary>
        public SourceLocation Location { get { return Command.Location; } }

        public string Evaluate(Configuration Config, ExecutionState State)
        {
            string commandStr = Command.Evaluate(Config, State);
            if (State.HasErrored)
                return "";

            string result = State.RunProcess(commandStr);
            if (State.HasErrored)
            {
                State.Log.LogError(new LogEntry(
                    "external error in '" + commandStr.Trim(null) + "'",
                    result,
                    Location));
                return "";
            }

            return result;
        }

        public override string ToString()
        {
            return "@(" + Command.ToString() + ")";
        }
    }

    public class ConcatExpression : IExpression
    {
        public const this(set IExpression Left, set IExpression Right);

        public IExpression Left { get; private set; }
        public IExpression Right { get; private set; }

        /// <summary>
        /// Gets this test expression's source location.
        /// </summary>
        public SourceLocation Location { get { return CompilerLogExtensions.Concat(Left.Location, Right.Location); } }

        /// <summary>
        /// Evaluates this test expression for the given configuration.
        /// </summary>
        public string Evaluate(Configuration Config, ExecutionState State)
        {
            return Left.Evaluate(Config, State) + Right.Evaluate(Config, State);
        }

        public override string ToString()
        {
            return Left.ToString() + Right.ToString();
        }
    }

    /// <summary>
    /// A test expression that evaluates to the empty string.
    /// </summary>
    public static class EmptyExpression : IExpression
    {
        /// <summary>
        /// Gets this test expression's source location.
        /// </summary>
        public SourceLocation Location { get { return null; } }

        public string Evaluate(Configuration Config, ExecutionState State)
        {
            return "";
        }

        public override string ToString()
        {
            return "";
        }
    }

    /// <summary>
    /// A statement that evaluates an expression, and executes the result
    /// as a command.
    /// </summary>
    public class CommandStatement : IStatement
    {
        public const this(set IExpression Command);

        /// <summary>
        /// Gets the expression that describes the command this
        /// statement should execute.
        /// </summary>
        public IExpression Command { get; private set; }

        /// <summary>
        /// Gets this test expression's source location.
        /// </summary>
        public SourceLocation Location { get { return Command.Location; } }

        public Configuration Execute(Configuration Config, ExecutionState State)
        {
            string commandStr = Command.Evaluate(Config, State);

            if (State.HasErrored)
                return Config;

            string result = State.RunProcess(commandStr);
            if (State.HasErrored)
            {
                State.Log.LogError(new LogEntry(
                    "external error in '" + commandStr.Trim(null) + "'",
                    result,
                    Location));
            }

            State.Write(result);

            return Config;
        }

        public override string ToString()
        {
            return Command.ToString() + ";";
        }
    }

    /// <summary>
    /// A statement that assigns a value to some variable.
    /// </summary>
    public class AssignmentStatement : IStatement
    {
        public const this(set Token Identifier, set IExpression Value);

        /// <summary>
        /// Gets the name of the variable to set, i.e. the left-hand side
        /// of the expression.
        /// </summary>
        public Token Identifier { get; private set; }

        /// <summary>
        /// Gets the expression whose value will be assigned to the variable,
        /// i.e. the right-hand side of the expression.
        /// </summary>
        public IExpression Value { get; private set; }

        /// <summary>
        /// Gets this test expression's source location.
        /// </summary>
        public SourceLocation Location { get { return CompilerLogExtensions.Concat(Identifier.Location, Value.Location); } }

        public Configuration Execute(Configuration Config, ExecutionState State)
        {
            string evalValue = Value.Evaluate(Config, State).Trim(null);
            return Config.WithVariable(Identifier.Contents, evalValue);
        }

        public override string ToString()
        {
            return Identifier.Contents + " = " + Value.ToString() + ";";
        }
    }

    /// <summary>
    /// A statement that executes two child statements in sequence.
    /// </summary>
    public class SequenceStatement : IStatement
    {
        public const this(set IStatement First, set IStatement Second);

        /// <summary>
        /// Gets the first statement to execute.
        /// </summary>
        public IStatement First { get; private set; }

        /// <summary>
        /// Gets the second statement to execute.
        /// </summary>
        public IStatement Second { get; private set; }

        /// <summary>
        /// Gets this test expression's source location.
        /// </summary>
        public SourceLocation Location { get { return CompilerLogExtensions.Concat(First.Location, Second.Location); } }

        public Configuration Execute(Configuration Config, ExecutionState State)
        {
            var newConfig = First.Execute(Config, State);
            return Second.Execute(newConfig, State);
        }

        public override string ToString()
        {
            var sb = new StringBuilder();
            string firstStr = First.ToString();
            if (!string.IsNullOrWhiteSpace(firstStr))
            {
                sb.Append(firstStr);
            }
            string secondStr = Second.ToString();
            if (!string.IsNullOrWhiteSpace(secondStr))
            {
                if (sb.Length > 0)
                    sb.AppendLine();
                sb.Append(secondStr);
            }
            return sb.ToString();
        }
    }

    /// <summary>
    /// A test statement that does nothing.
    /// </summary>
    public static class EmptyStatement : IStatement
    {
        /// <summary>
        /// Gets this test expression's source location.
        /// </summary>
        public SourceLocation Location { get { return null; } }

        public Configuration Execute(Configuration Config, ExecutionState State)
        {
            return Config;
        }

        public override string ToString()
        {
            return ";";
        }
    }
}
